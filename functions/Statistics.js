module.exports = {
    name: 'Statistics',
    description: 'Gets all the statistics form all servers and sends through different functions',
    /**
     * This function is only used for the main guild (later can be scaled) to update users with roles and allow them to use features like setting image or gif.
     * This function keeps track on users statistical data that includes xp, level, sent message number, etc.
     * @param {Discord.Message} msg 
     * @param {Array<string} args 
     * @param {Discord.Client} bot 
     * @returns 
     */
    async execute(msg, args, bot){

        if(msg.author.id === process.env.USER_BOT) return;
        
        //-----------------------------------------------------------------------------------
        // Additional variables
        const fs = require('fs'); //eslint-disable-line
        const jsonfile = require('jsonfile'); //eslint-disable-line
        const random = require('random');
        const { Client } = require('pg');
        const Discord = require('discord.js');
        let stats = {};
        //-----------------------------------------------------------------------------------

        //-----------------------------------------------------------------------------------
        // Connecting to the database
        const client = new Client({
        connectionString: process.env.DATABASE_URL,
        ssl: {
            rejectUnauthorized: false
        }
        });

        client.connect();
        //-----------------------------------------------------------------------------------

        const createTableusers = `CREATE TABLE IF NOT EXISTS users(
            id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            data json NOT NULL
        )`;
        // if any time I will want to make this bot global then change that the id of the table is guild id because json file is going to be insane

        await client.query(createTableusers).catch(err => {console.error(err);}); //eslint-disable-line

        // Getting information about all previous levels
        const { rows } = await client.query('SELECT * FROM users');

        try {
            stats = rows[0].data;
        }catch(err){
            stats = {};
        }
        
        //-------------------------------------------------------------------------------------------------------------------------------------------------------------------
        // If there were no previous guild or user in the database then they are added to it with additional information that should automaticly update
        if(msg.guild.id in stats === false){
            stats[msg.guild.id] = {
                name: msg.guild.name,
                guild_id: msg.guild.id
            };
        }

        const serverStats = stats[msg.guild.id];

        if(msg.author.id in serverStats === false){
            serverStats[msg.author.id] = {
                name: msg.author.username,
                user_id: msg.author.id, 
                OverallXp: 0,
                CurrentXp: 0,
                level: 0,
                Next_Level_At: 0,
                xpToNextLevel: 0,
                MessagesSent: 0,
                Last_message: 0,
                MessageLength: 0,
            };
        }
        //-------------------------------------------------------------------------------------------------------------------------------------------------------------------

        const userStats = serverStats[msg.author.id];

        const  previous_level = userStats.level;

        //fetch 10 messages
        //sort by id
        //check wether 3 or more messages are the same
        //Really quick and easy bypass to auto spams - check if messages are in 6000ms range
        if(msg.author.id !== process.env.USER_OWNER)
        {        
            let spammers = [];
                let index = 0;
                await msg.channel.messages.fetch({cache: true, limit: 10})
                .then(messages => messages.each(m => spammers.push({id: m.author.id, content: m.content, time: m.createdAt.getTime()})))
                .catch(err => console.log('Error while trying to push to an array. \n' + err));
                for(var j = 0; j < spammers.length; j++){
                    if(spammers[0].id === spammers[j].id){
                        if(spammers[0].content === spammers[j].content || isNaN(spammers[j].content.replace(',', '.').replace('E-','')) === false)
                            {
                                index++;
                            }
                        else if(Date.now() - spammers[j].time <= 6000*(j+1)){
                            index++;
                        }
                        }
                }
                if(index >= 3){
                    return client.end();
                }
        }

        if(Date.now() - userStats.Last_message >= 5000 || msg.author.id === process.env.USER_OWNER){
            
        if(msg.author.id === process.env.USER_OWNER) var amount = random.int(15, 25) + msg.content.length; // new variable so that the amount of xp for current and overall would be the same
        else if(msg.content.length >= 200) var amount = random.int(15, 25) + 200; // eslint-disable-line
        else var amount = random.int(15, 25) + msg.content.length; // eslint-disable-line

        userStats.CurrentXp += amount;
        userStats.OverallXp +=  amount;

        userStats.MessagesSent++;

        if(msg.attachments.size > 0){
            amount = msg.attachments.size * random.int(30, 55);

            userStats.CurrentXp += amount;
            userStats.OverallXp += amount;
        }

        userStats.Next_Level_At = 3 * Math.pow(userStats.level, 2) + 100 * userStats.level + 100;
        

        if(userStats.CurrentXp >= userStats.Next_Level_At){
            userStats.CurrentXp -= userStats.Next_Level_At;
            userStats.level++;
            userStats.Next_Level_At = 3 * Math.pow(userStats.level, 2) + 100 * userStats.level + 100;
            msg.channel.send(`**${msg.author.username} pasiekė ${userStats.level} lygį!**`);
        }
        
        userStats.xpToNextLevel = (3 * Math.pow(userStats.level, 2) + 100 * userStats.level + 100) - userStats.CurrentXp;

        userStats.Last_message = Date.now();

        if(!userStats.MessageLength)
            userStats.MessageLength = msg.content.length;
        else userStats.MessageLength += msg.content.length; 
    }

        const current_level = userStats.level;
        //await jsonfile.writeFileSync(`./functions/JsonFiles/stats.json`, stats, { spaces: 2}); // uncomment this then run and see all the info in the database

        //console.log(stats);

        // Updating the json file
        await client.query("UPDATE users SET data = '" + JSON.stringify(stats) + "'").catch(err => {bot.users.get(OwnerID).send(`There has been an error with updating database : ${err}`);console.log(err);}); // eslint-disable-line

        //var text = jsonfile.readFileSync('./functions/JsonFiles/stats.json');
        
        //jsonfile.writeFileSync(`./functions/JsonFiles/stats1.json`, stats, { spaces: 2});

        
//------------------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // Creating and adding roles to people who have met certain level requirements
    // END POINT FOR GLOBAL GUILDS
    const guild = (await bot.guilds.fetch(process.env.GUILD));
    if(msg.guild.id !== guild.id) return client.end();

    //----------------------------------------------------------
    // Getting new role info
    var role_data = await client.query('SELECT * FROM Roles');

    const Roles = role_data.rows[0].roles;
    //----------------------------------------------------------

    client.end();

    //-----------------------------------------------------------------------------------
    // One time role checker for upcoming and gained levels
    // Need to read roles and get their positions the slice of unnecessary and calculate the position than is needed to be
    
    if(previous_level === current_level) return;
    if(userStats.level in Roles){
        var role_info = Roles[userStats.level]; // new role by leveling up

        const userRoles = (await msg.guild.members.fetch(msg.author.id)).roles.cache.filter(role => role.name !== null);
        let userRoleLevel;
        userRoles.each(role => {
            if(userRoleLevel)
                return;

            Object.keys(Roles).forEach(level => {
            if(Roles[level].name === role.name)
                return userRoleLevel = level;
            });
        });

        const previous_role = Roles[userRoleLevel];
        var dbroles = new Map();
        Object.keys(Roles).forEach(level => dbroles.set(Roles[level].name, 1));

        var All_roles = new Map();
        var flag = false;
                    
        (await guild.roles.fetch()).each(role => {

            if(flag)
                All_roles.set(role.name, ++role.position);
            else 
                All_roles.set(role.name, role.position);

            if(previous_role.name === role.name)
            {
                flag = true;
                All_roles.set(role_info.name, ++role.position);
            }
            
        });

            if(!(await guild.roles.fetch()).find(r => r.name === role_info.name)){
                await guild.roles.create({
                        name: role_info.name,
                        color: role_info.color,
                        position: All_roles.get(role_info.name),
                        permissions: ['SEND_MESSAGES'],
                        mentionable: true,
                        hoist: true,
                        reason: `${msg.author.username} leveled up and now can have a new role.`,
                }).then(async () => {

                    (await guild.channels.fetch()).find(channel => channel.name === 'logs').send(`Created new role **${role_info.name}**`);
                    
                }).catch(err => console.log(err));
            }

        const member = (await guild.members.fetch(msg.author.id));

        var member_role_previous = member.roles.cache.find(r => r.name === previous_role.name);
        // removing the previous role
        if (member_role_previous) member.roles.remove(member_role_previous); 
    
        //Adding the new role
        if(!member.roles.cache.find(r => r.name === role_info.name)) await member.roles.add(guild.roles.cache.find(r => r.name ===  role_info.name)).then(()=>{
            msg.channel.send('**' + msg.author.username + '**' + ' has been promoted to: **'+ role_info.name +'**');
        });

    // Removing empty roles  
    var role_size = new Map();
    var embed = new Discord.MessageEmbed();
    embed.setAuthor(bot.user.username, bot.user.avatarURL())
    .setColor('RED')
    .setTimestamp(msg.createdTimestamp)
    .setTitle('Deleted roles')
    .setDescription('Roles that have been deleted since no players are in them.');
    (await (await bot.guilds.fetch(process.env.GUILD)).roles.fetch()).each(role => role_size.set(role.name, 0));
    (await (await bot.guilds.fetch(process.env.GUILD)).members.fetch()).each(member => {
        member.roles.cache.each(role => {
            role_size.set(role.name, role_size.get(role.name)+1);
        });
    });
    
    var arr = [];
    (await (await bot.guilds.fetch(process.env.GUILD)).roles.fetch()).each(async role => {
        if(role_size.get(role.name) === 0 && dbroles.has(role.name)){
            arr.push(role.name);
            await role.delete('No members are in the role');
        }  
    });
    if(arr.length!==0){
        embed.addField('Roles', arr.join('\n'));
        
        (await guild.channels.fetch()).find(channel => channel.name === 'logs').send({embeds: [embed]});
    }
    }
        return;
    }
};  